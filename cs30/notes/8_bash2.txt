
###
### Well-Behaved Script article
###

.sh file ending convention

USERS=`who | wc -l`
if [ $USERS -eq 0 ] ; then
    sync
fi


# Structure of a good bash script:

Header
Global Declarations
Sanity Checks
Main Script
Cleanup

### Header

#!/bin/bash
-first line, absolute pathname indicating where Bash interpreter resides
-whereis bash to find

### Global Declarations

declare -rx who="/usr/bin/who"

### Sanity Checks

don't let the script begin its main task unless the computer is in a known/sane state

if test -z "$BASH" ; then
.... #abort, no bash
fi

if test ! -x "$who" ; then
... # abort, no who command available
fi
man test

### Main Script

esketit or do the stuff

### Cleanup

-delete temporary files
-track/return status code from failed command(s)

exit 0 # all is well

exit 1 # error code 1
exit 3 # error code 3

suspend # wait until notified 

sleep 5 # wait for 5 seconds
- good for enabling user readability of screen output, maybe
- NOT good for synchronizing events


###
### the printf statement
###

 printf "format" "$variable1" "$variable2" "$variablen"  


%c Character data

%d Decimal number such as 10,-5  etc

%.nd Decimal number with optional n = number of columns; if n is 0, pad with zeroes

%x Hexadecimal number such as 0xA, 0xffff etc

%s String data such as "vivek", "Good buy"

%ns String data with optional n = number of columns

\n   \t \a Introduce new line (\n) or tab (\t) or bell (\a)

n="10"
printf "%d" "$n"

-- # used to tell command/program that whatever follows is NOT a command line option (but, an argument maybe?)


###
### Arithmetic with Bash
###

format: $((EXPRESSION))

SEVEN=$((5+2))
echo $SEVEN

evaluation is done in fixed-width integers, with no check for overflow


http://www.vias.org/linux-knowhow/bbg_sect_03_04_06.html

operators, listed in DECREASING precedence:

Operator	Meaning
VAR++ and VAR--	variable post-increment and post-decrement
++VAR and --VAR	variable pre-increment and pre-decrement
- and +	unary minus and plus
! and ~	logical and bitwise negation
**	exponentiation
*, / and %	multiplication, division, remainder
+ and -	addition, subtraction
<< and >>	left and right bitwise shifts
<=, >=, < and >	comparison operators
== and !==	equality and inequality
&	bitwise AND
^	bitwise exclusive OR
|	bitwise OR
&&	logical AND
||	logical OR
expr ? expr : expr	conditional evaluation
=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^= and |=	assignments
,	separator between expressions

leading 0 - interpreted as octal
leading 0x - interpreted as hex

"[BASE'#']N" 

$[ EXPRESSION ] - this syntax calculates expression result, but does no tests


###
### Selection Structures
###

#! - shebang, prefix specifying which shell the script was written for
-if not exists, script executed under current shell

#!/bin/bash
#! = this is a shell script, and next several bytes, up to a newline character, make up the name of the binary that the OS should run, feeding it the script

Top Down line-by-line execution, left to right.

CONDITIONAL PROCESSING

test command, or [] - evaluate conditional expressions

test expression (integers only. decimal values truncated)
[ expression ]

- wildcards in string comparison should ONLY be used in a case statement. test command will force shell to interpret wildcards as a filename search.


### Numeric Comparisons

int1 -eq int2
Returns True if int1 is equal to int2.

int1 -ge int2
Returns True if int1 is greater than or equal to int2.

int1 -gt int2
Returns True if int1 is greater than int2.

int1 -le int2
Returns True if int1 is less than or equal to int2

int1 -lt int2
Returns True if int1 is less than int2

int1 â€“ne int2
Returns True if int1 is not equal to int2


### String Comparisons

str1 = str2
Returns True if str1 is identical to str2.

str1 != str2
Returns True if str1 is not identical to str2.

Str
Returns True if str is not null.

-n str
Returns True if the length of str is greater than zero.

-z str
Returns True if the length of str is equal to zero. (zero is different than null)

### File Comparisons

-d filename
Returns True if file, filename is a directory.

-f filename
Returns True if file, filename is an ordinary file.

-r filename
Returns True if file, filename can be read by the process.

-s filename
Returns True if file, filename has a nonzero length.

-w filename
Returns True if file, filename can be written by the process.

-x filename
Returns True if file, filename is executabl


### Expression Comparisons

!expression
Returns true if expression is not true

expr1 -a expr2
Returns True if expr1 and expr2 are true. ( && , and )

expr1 -o expr2
Returns True if expr1 or expr2 is true. ( ||, or )


### If statements

IF ------

if test expression
then
    action
fi

if [ expression ]
then
    action
fi

IF ELSE ------

if [ condition ]
then
    action1
else
    action2
fi

IF ELSE IF ------

if [ condition1 ]
then
    action1
elif [ condition2 ]
then
    action2
fi

IF ELSE IF ELSE ------

if [ condition1 ]
then
    action1
elif [ condition2 ]
then
    action2
else
    action3
fi


### LOGICAL OPERATORS

&& and
|| or

if [ $number -gt 10] || [ $number -lt -10 ] # out of range!
if [ $number -gt -10] && [ $number -lt 10 ] # in range



### 
###
### the read command
###

make scripts interactive
-take input from keyboard and assign it to variable

#!/bin/bash
echo -n "Enter some text > " # -n option of echo keeps cursor on same line
read text
echo "You entered: $text"

(alternatively, not setting read input to a variable, and using environment variable $REPLY)

#!/bin/bash
echo -n "Enter some text > " # -n option of echo keeps cursor on same line
read
echo "You entered: $REPLY"

READ OPTIONS

read -t 5 # set timer for 5 seconds

echo -n "Hurry up and type something! > "
if read -t 3 response; then
    echo "Great, you made it in time!"
else
    echo "Sorry, you are too slow!"
fi

read -s # hide what user is typing, good for password

###
### bash scripting challenge
###

FUNCTIONS:

some_func()
{

}

$(some_func)

###
### positional parameters
###

>$ some_program word1 word2 word3

$0 = "some_program"
$1 = "word1"
$2 = "word2"
$3 = "word3"

TWO WAYS TO DETECT COMMAND LINE ARGUMENTS::

#!/bin/bash

if [ "$1" != "" ]; then
    echo "Positional parameter 1 contains something"
else
    echo "Positional parameter 1 is empty"
fi

#!/bin/bash

if [ $# -gt 0 ]; then
    echo "Your command line contains $# arguments"
else
    echo "Your command line contains no arguments"
fi

setting an empty variable:
someEmptyVar=


PROCESS COMMAND LINE ARGUMENTS BY USING SHIFT:
(shift makes $3 to $2, $2 to $1, etc)


interactive=
filename=~/sysinfo_page.html

while [ "$1" != "" ]; do
    case $1 in
        -f | --file )           shift
                                filename="$1"
                                ;;
        -i | --interactive )    interactive=1
                                ;;
        -h | --help )           usage
                                exit
                                ;;
        * )                     usage
                                exit 1
    esac
    shift
done

###
### LAB QUIZ 8
###

when a script is run by ./scriptName
- current shell starts a child shell, that reads the script file and runs listed commands
- execute permission (+x) is needed on the script file
- execute permission = can/can't start a child shell to run the script file
- read permission (+r) is also needed on the script file
- read permission = child shell can read the file to execute it


chmod a=rwx permtest
chmod a=r permtest
chmod ug=rw,o=r permtest
chmod u-x,o+r permtest
chmod u=rwx,go= permtest

MORE SPECIFIC PERMISSIONS TAKE PRECEDENCE OVER LESS SPEFICIC

user > group > other

777, 755, etc = UGO :

0	Grants no permissions (removes all)
1	Grants execute permission only
2	Grants write permission only
3	Grants write and execute permission (2 + 1)
4	Grants read permission only
5	Grands read and execute permission (4 + 1)
6	Grants read and write permission (4 + 2)
7	Grants read and write and execute permissions (4 + 2 + 1)

Whether a user can remove a file is determined by whether the person has write permission to the file.  
rm makes an exception if the person is the owner of the file to save a step. (bc, owner could give themselves permissions)

kill -2 PID # same as CTRL-C
kill -3 PID # same as CTRL-\

### FIND UTILITY

find /tmp -user $USER -print
find ~ -name practice -print

Use -exec to get the find command to execute another utility once it finds what you are looking for. 

find /tmp -user $USER -exec head -2 {} \; -print

find /tmp -user $USER -exec ls -lFi {} \; -print 2> /dev/null

