###
### Ch. 26 - Concurrency: An Introduction
###

Multi-threaded programs have more than 1 point of execution

Threads are similar to Processes, but they share the same Address Space

Threads running on a single CPU similar Context Switch, but Address Space stays the same

Similar to PCB Process Control Block,
a Processes needs TCBs Thread Control Blocks to save the state of its threads

Stack-allocated variables are Thread-Local
-To share data between Threads, the HEAP must be used

Why Use Threads?
- Parallelism - multiple processors can each perform a unit of work
- Avoid I/O blocking - while one thread is blocked for I/O, CPU can switch to another thread and continue work

OBJDUMP - Linux disassembler

Shared Data can lead to a Race Condition
Critical Section - part of code containing shared data
Mutual Exclusion - protection against race conditions

ATOMICITY - strive for atomic, "all or nothing" transactions. This allows multi-threaded code to access Critical Sections, and be OK

SYNCHRONIZATION PRIMITIVES - hardware instructions that, in tandem with OS, work to support Concurrency

Definitions:
Critical Section - piece of code accessing a shared resource
Race Condition (data race) - arises if multiple threads enter a critical section at roughly the same time
- many threads attempt to update the shared data structure, leading to unexpected outcomes
Indeterminate - program containing <=1 race conditions. Outcome is not deterministic
Mutual Exclusion - primitives used by threads to prevent multiples concurrent entries into a critical section


###
### Ch. 27 - Interlude: Thread API
###

POXIS pthread library

https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html

pthread_t - POSIX Thread type

pthread_create - Thread creation

pthread_join - Thread completion

pthread_mutex_t - POSIX Lock type

pthread_mutex_lock - lock a Lock

pthread_mutex_unlock - unlock a Lock

PTHREAD_MUTEX_INITIALIZER

pthread_cond_wait - Condition Variable wait

pthread_cond_signal - Condition Variable signal

gcc -pthread (include for Compile)



###
### Ch. 28 - Locks
###

Annotate source code - place Locks around critical sections, so only 1 thread at a time, can access the critical section

Coarse-Grained vs Fine-Grained Locking approach
- how much code is contained in a single lock?

Evaluating Locks
- mutual exclusion - the basic task
- fairness
- performance

Spin/Wait - wasting CPU cycles, waiting on a Lock to be unlocked

Spin Lock - requires a Preemptive Scheduler to work on a single CPU

Test-And-Set : atomic hardware primitive

Compare-And-Swap: hardware primitive

Load-Linked & Store-Conditional: hardware primitives

Fetch-And-Add: hardware primitive

How to avoid Spinning?
- Thread can yield
- Queues/sleeping
- wakeup/waiting race

Linux-based Futex locks



###
### Ch. 29 - Lock-based Concurrent Data Structures
###

How to make various data structures Thread-Safe?
- Add LOCKS!

Counter
-for multi-CPU, Approximation
-local counts
-global count
-local counts added to global count when at a certain threshold
(numLocal * threshold) = error possible

Linked List
-Locks in insert() and lookup()
-Hand-over-Hand locks; instead of a single Lock for the entire Linked List, Lock per Node

Queue
- dummy node added, to seperate head (dequeue) and tail (enqueue) operations
- Locks in enqueue() and dequeue()

Hash Table
- array of Thread-Safe Linked Lists
- performance scales much better than a single Linked List due to Hash Bucket division of labor


###
### Ch. 30 - Condition Variables
###

Thread needs to check if a condition is true, before continuing execution

join() - parent thread checking to see if child thread has finished

Condition Variable - explicit queue that threads can put themselves on when some state of execution is not as desired
- by waiting on the condition
- another thread can change the execution state, WAKING the other thread(s)
- this thread SIGNALS on the condition

pthread_cond_t - Condition Variable type
pthread_cond_wait - wait() for a condition variable state (WAITING on another thread)
pthread_cond_signal - signal() for a condition variable state (WAKING other threads)

"Hold the Lock while calling Signal or Wait"

PRODUCER/CONSUMER (BOUNDED BUFFER) PROBLEM
- producer threads generate data items and place them in a buffer
- consumer threads grab data itesm from the buffer and consume them

Eg: Web server, (multi-threaded) - HTTP requests placed into work queue by producer threads
- consumer threads take requests out of queue and process them

grep foo file.txt | wc -l

- PIPING produces a bounded buffer / producer-consumer pattern

EMPTY, FILL Condition Variables, While, used to solve Producer/Consumer

Covering Conditions - signal vs broadcast
- wake up possibly too many threads, to avoid not having any threads woken up


###
### Ch. 31 - Semaphores
###

Semaphore - single primitive for all things Sychronization
- can use semaphore as both Locks and Condition Variables

Semaphore = an object with an integer value, that can be manipulated with 2 routines in POSIX:
- sem.wait()
- sem.post()

sem.init() - initalize value

Binary Semaphore - LOCK USE

Semaphores for Ordering - CONDITION VARIABLE USE

Producer/Consumer and Semaphores

Reader-Writer Locks
- multiple concurrent readers is OK
- a writer and a reader cannot be concurrent

Dining Philosophers
- break symmetric dependency (1 looks right instead of left)

Cigarette Smoker's Problem

Sleeping Barber Problem


###
### Ch. 32 - Common Concurrency Problems
###

NON-DEADLOCK

Atomicity-Violation
- a code region is meant to be atomic, but that's not enforced during execution
- can fix by simply adding Locks ?

Order-Violation
- desired order between 2 groups of memory access is flipped / not enforced
- can fix with Condition Variables ?

DEADLOCK

Deadlock = a CYCLE in a DEPENDENCY GRAPH

4 required conditions:
- mutual exclusion (threads claim control, aka, grab Lock)
- hold-and-wait: threads hold resources allocated to them (eg Lock), while waiting for additional resources (eg, another Lock)
- no preemption: resources (Locks) can't be forcily removed from Threads holding them
- circular wait: a circular chain of threads exist, such that each thread holds resources (Locks) requested by next thread in chain

Prevent Circular Wait
-total/partial ordering of Lock acquisition

Prevent Hold-and-wait
- acquire all locks at once, atomically

Prevent No Preemption
- TryLock - can result in LIVELOCK

Prevent Mutual Exclusion
- lock-free/wait-free approaches: lean on powerful Hardware instructions, instead of explicitly locking

Avoid instead of Prevent:
-via Scheduling

Detect and Recover
-cycle in dependency graph?


###
### Ch. 33 - Event-based Concurrency
###

eg, nodeJS
https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/

Event Loop

-wait for something to occur
-determine what type of event it is
- do the small amount of work it requires
    - this may be IO request issue, scheduling other events, etc

Event Handler - code that processes each event

API:
select()
poll()

check if there's incoming IO that needs to be attended to
read? write? exception?

Synchronous: BLOCKING
Asynchronous: NON-BLOCKING

Event Based systems CANNOT ALLOW BLOCKING
- Asynchronous I/O is crucial

Unix signals, signal handlers, interrupts

State Management - program state is no longer stored on Stack of Threads
- manual stack management needed

Continuation - programming construct, record info to finish processing an event, and look it up when needed (when event happens)